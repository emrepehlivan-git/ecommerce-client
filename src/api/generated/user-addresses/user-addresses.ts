/**
 * Generated by orval v7.9.0 🍺
 * Do not edit manually.
 * ECommerce API
 * ECommerce API with OpenIddict Authentication and Versioning
 * OpenAPI spec version: v1
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AddUserAddressCommand,
  DeleteUserAddressRequest,
  GetApiV1UserAddressesUserUserIdParams,
  ProblemDetails,
  Result,
  SetDefaultRequest,
  UpdateUserAddressRequest,
  UserAddressDto
} from '.././model';

import { axiosClientMutator } from '../../../lib/axiosClient';




export const getApiV1UserAddressesUserUserId = (
    userId: string,
    params?: GetApiV1UserAddressesUserUserIdParams,
 signal?: AbortSignal
) => {
      
      
      return axiosClientMutator<UserAddressDto[]>(
      {url: `/api/v1/UserAddresses/user/${userId}`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetApiV1UserAddressesUserUserIdQueryKey = (userId: string,
    params?: GetApiV1UserAddressesUserUserIdParams,) => {
    return [`/api/v1/UserAddresses/user/${userId}`, ...(params ? [params]: [])] as const;
    }

    
export const getGetApiV1UserAddressesUserUserIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getApiV1UserAddressesUserUserId>>, GetApiV1UserAddressesUserUserIdParams['page']>, TError = ProblemDetails>(userId: string,
    params?: GetApiV1UserAddressesUserUserIdParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getApiV1UserAddressesUserUserId>>, TError, TData, Awaited<ReturnType<typeof getApiV1UserAddressesUserUserId>>, QueryKey, GetApiV1UserAddressesUserUserIdParams['page']>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiV1UserAddressesUserUserIdQueryKey(userId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiV1UserAddressesUserUserId>>, QueryKey, GetApiV1UserAddressesUserUserIdParams['page']> = ({ signal, pageParam }) => getApiV1UserAddressesUserUserId(userId,{...params, 'page': pageParam || params?.['page']}, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(userId),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getApiV1UserAddressesUserUserId>>, TError, TData, Awaited<ReturnType<typeof getApiV1UserAddressesUserUserId>>, QueryKey, GetApiV1UserAddressesUserUserIdParams['page']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiV1UserAddressesUserUserIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getApiV1UserAddressesUserUserId>>>
export type GetApiV1UserAddressesUserUserIdInfiniteQueryError = ProblemDetails


export function useGetApiV1UserAddressesUserUserIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getApiV1UserAddressesUserUserId>>, GetApiV1UserAddressesUserUserIdParams['page']>, TError = ProblemDetails>(
 userId: string,
    params: undefined |  GetApiV1UserAddressesUserUserIdParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getApiV1UserAddressesUserUserId>>, TError, TData, Awaited<ReturnType<typeof getApiV1UserAddressesUserUserId>>, QueryKey, GetApiV1UserAddressesUserUserIdParams['page']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiV1UserAddressesUserUserId>>,
          TError,
          Awaited<ReturnType<typeof getApiV1UserAddressesUserUserId>>, QueryKey
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiV1UserAddressesUserUserIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getApiV1UserAddressesUserUserId>>, GetApiV1UserAddressesUserUserIdParams['page']>, TError = ProblemDetails>(
 userId: string,
    params?: GetApiV1UserAddressesUserUserIdParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getApiV1UserAddressesUserUserId>>, TError, TData, Awaited<ReturnType<typeof getApiV1UserAddressesUserUserId>>, QueryKey, GetApiV1UserAddressesUserUserIdParams['page']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiV1UserAddressesUserUserId>>,
          TError,
          Awaited<ReturnType<typeof getApiV1UserAddressesUserUserId>>, QueryKey
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiV1UserAddressesUserUserIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getApiV1UserAddressesUserUserId>>, GetApiV1UserAddressesUserUserIdParams['page']>, TError = ProblemDetails>(
 userId: string,
    params?: GetApiV1UserAddressesUserUserIdParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getApiV1UserAddressesUserUserId>>, TError, TData, Awaited<ReturnType<typeof getApiV1UserAddressesUserUserId>>, QueryKey, GetApiV1UserAddressesUserUserIdParams['page']>>, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetApiV1UserAddressesUserUserIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getApiV1UserAddressesUserUserId>>, GetApiV1UserAddressesUserUserIdParams['page']>, TError = ProblemDetails>(
 userId: string,
    params?: GetApiV1UserAddressesUserUserIdParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getApiV1UserAddressesUserUserId>>, TError, TData, Awaited<ReturnType<typeof getApiV1UserAddressesUserUserId>>, QueryKey, GetApiV1UserAddressesUserUserIdParams['page']>>, }
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiV1UserAddressesUserUserIdInfiniteQueryOptions(userId,params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetApiV1UserAddressesUserUserIdQueryOptions = <TData = Awaited<ReturnType<typeof getApiV1UserAddressesUserUserId>>, TError = ProblemDetails>(userId: string,
    params?: GetApiV1UserAddressesUserUserIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1UserAddressesUserUserId>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiV1UserAddressesUserUserIdQueryKey(userId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiV1UserAddressesUserUserId>>> = ({ signal }) => getApiV1UserAddressesUserUserId(userId,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(userId),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiV1UserAddressesUserUserId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiV1UserAddressesUserUserIdQueryResult = NonNullable<Awaited<ReturnType<typeof getApiV1UserAddressesUserUserId>>>
export type GetApiV1UserAddressesUserUserIdQueryError = ProblemDetails


export function useGetApiV1UserAddressesUserUserId<TData = Awaited<ReturnType<typeof getApiV1UserAddressesUserUserId>>, TError = ProblemDetails>(
 userId: string,
    params: undefined |  GetApiV1UserAddressesUserUserIdParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1UserAddressesUserUserId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiV1UserAddressesUserUserId>>,
          TError,
          Awaited<ReturnType<typeof getApiV1UserAddressesUserUserId>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiV1UserAddressesUserUserId<TData = Awaited<ReturnType<typeof getApiV1UserAddressesUserUserId>>, TError = ProblemDetails>(
 userId: string,
    params?: GetApiV1UserAddressesUserUserIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1UserAddressesUserUserId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiV1UserAddressesUserUserId>>,
          TError,
          Awaited<ReturnType<typeof getApiV1UserAddressesUserUserId>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiV1UserAddressesUserUserId<TData = Awaited<ReturnType<typeof getApiV1UserAddressesUserUserId>>, TError = ProblemDetails>(
 userId: string,
    params?: GetApiV1UserAddressesUserUserIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1UserAddressesUserUserId>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetApiV1UserAddressesUserUserId<TData = Awaited<ReturnType<typeof getApiV1UserAddressesUserUserId>>, TError = ProblemDetails>(
 userId: string,
    params?: GetApiV1UserAddressesUserUserIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1UserAddressesUserUserId>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiV1UserAddressesUserUserIdQueryOptions(userId,params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const postApiV1UserAddresses = (
    addUserAddressCommand: AddUserAddressCommand,
 signal?: AbortSignal
) => {
      
      
      return axiosClientMutator<string>(
      {url: `/api/v1/UserAddresses`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: addUserAddressCommand, signal
    },
      );
    }
  


export const getPostApiV1UserAddressesMutationOptions = <TError = ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiV1UserAddresses>>, TError,{data: AddUserAddressCommand}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postApiV1UserAddresses>>, TError,{data: AddUserAddressCommand}, TContext> => {

const mutationKey = ['postApiV1UserAddresses'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiV1UserAddresses>>, {data: AddUserAddressCommand}> = (props) => {
          const {data} = props ?? {};

          return  postApiV1UserAddresses(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiV1UserAddressesMutationResult = NonNullable<Awaited<ReturnType<typeof postApiV1UserAddresses>>>
    export type PostApiV1UserAddressesMutationBody = AddUserAddressCommand
    export type PostApiV1UserAddressesMutationError = ProblemDetails

    export const usePostApiV1UserAddresses = <TError = ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiV1UserAddresses>>, TError,{data: AddUserAddressCommand}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiV1UserAddresses>>,
        TError,
        {data: AddUserAddressCommand},
        TContext
      > => {

      const mutationOptions = getPostApiV1UserAddressesMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    export const putApiV1UserAddressesId = (
    id: string,
    updateUserAddressRequest: UpdateUserAddressRequest,
 ) => {
      
      
      return axiosClientMutator<Result>(
      {url: `/api/v1/UserAddresses/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateUserAddressRequest
    },
      );
    }
  


export const getPutApiV1UserAddressesIdMutationOptions = <TError = ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putApiV1UserAddressesId>>, TError,{id: string;data: UpdateUserAddressRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof putApiV1UserAddressesId>>, TError,{id: string;data: UpdateUserAddressRequest}, TContext> => {

const mutationKey = ['putApiV1UserAddressesId'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putApiV1UserAddressesId>>, {id: string;data: UpdateUserAddressRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  putApiV1UserAddressesId(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutApiV1UserAddressesIdMutationResult = NonNullable<Awaited<ReturnType<typeof putApiV1UserAddressesId>>>
    export type PutApiV1UserAddressesIdMutationBody = UpdateUserAddressRequest
    export type PutApiV1UserAddressesIdMutationError = ProblemDetails

    export const usePutApiV1UserAddressesId = <TError = ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putApiV1UserAddressesId>>, TError,{id: string;data: UpdateUserAddressRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putApiV1UserAddressesId>>,
        TError,
        {id: string;data: UpdateUserAddressRequest},
        TContext
      > => {

      const mutationOptions = getPutApiV1UserAddressesIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    export const deleteApiV1UserAddressesId = (
    id: string,
    deleteUserAddressRequest: DeleteUserAddressRequest,
 ) => {
      
      
      return axiosClientMutator<Result>(
      {url: `/api/v1/UserAddresses/${id}`, method: 'DELETE',
      headers: {'Content-Type': 'application/json', },
      data: deleteUserAddressRequest
    },
      );
    }
  


export const getDeleteApiV1UserAddressesIdMutationOptions = <TError = ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteApiV1UserAddressesId>>, TError,{id: string;data: DeleteUserAddressRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteApiV1UserAddressesId>>, TError,{id: string;data: DeleteUserAddressRequest}, TContext> => {

const mutationKey = ['deleteApiV1UserAddressesId'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteApiV1UserAddressesId>>, {id: string;data: DeleteUserAddressRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  deleteApiV1UserAddressesId(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteApiV1UserAddressesIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteApiV1UserAddressesId>>>
    export type DeleteApiV1UserAddressesIdMutationBody = DeleteUserAddressRequest
    export type DeleteApiV1UserAddressesIdMutationError = ProblemDetails

    export const useDeleteApiV1UserAddressesId = <TError = ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteApiV1UserAddressesId>>, TError,{id: string;data: DeleteUserAddressRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteApiV1UserAddressesId>>,
        TError,
        {id: string;data: DeleteUserAddressRequest},
        TContext
      > => {

      const mutationOptions = getDeleteApiV1UserAddressesIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    export const patchApiV1UserAddressesIdSetDefault = (
    id: string,
    setDefaultRequest: SetDefaultRequest,
 ) => {
      
      
      return axiosClientMutator<Result>(
      {url: `/api/v1/UserAddresses/${id}/set-default`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: setDefaultRequest
    },
      );
    }
  


export const getPatchApiV1UserAddressesIdSetDefaultMutationOptions = <TError = ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchApiV1UserAddressesIdSetDefault>>, TError,{id: string;data: SetDefaultRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patchApiV1UserAddressesIdSetDefault>>, TError,{id: string;data: SetDefaultRequest}, TContext> => {

const mutationKey = ['patchApiV1UserAddressesIdSetDefault'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchApiV1UserAddressesIdSetDefault>>, {id: string;data: SetDefaultRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  patchApiV1UserAddressesIdSetDefault(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchApiV1UserAddressesIdSetDefaultMutationResult = NonNullable<Awaited<ReturnType<typeof patchApiV1UserAddressesIdSetDefault>>>
    export type PatchApiV1UserAddressesIdSetDefaultMutationBody = SetDefaultRequest
    export type PatchApiV1UserAddressesIdSetDefaultMutationError = ProblemDetails

    export const usePatchApiV1UserAddressesIdSetDefault = <TError = ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchApiV1UserAddressesIdSetDefault>>, TError,{id: string;data: SetDefaultRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patchApiV1UserAddressesIdSetDefault>>,
        TError,
        {id: string;data: SetDefaultRequest},
        TContext
      > => {

      const mutationOptions = getPatchApiV1UserAddressesIdSetDefaultMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    